# Módulo Padrões de Projeto GoFs Comportamentais

Os padrões de projeto comportamentais do Gang of Four (GoF) são uma coleção de soluções projetadas para gerenciar algoritmos, relacionamentos e responsabilidades entre objetos. Esses padrões facilitam a comunicação entre objetos e promovem a flexibilidade e reutilização do código.

Eles são particularmente úteis para lidar com situações em que é necessário definir a maneira como os objetos interagem e colaboram, garantindo um comportamento coerente e previsível em um sistema.

Os principais padrões de projeto comportamentais GoF incluem:

### Chain of Responsibility

Permite que vários objetos tenham a oportunidade de tratar uma solicitação, passando-a ao longo de uma cadeia de handlers.

### Command

Encapsula uma solicitação como um objeto, permitindo parametrizar clientes com diferentes solicitações, enfileirar ou registrar solicitações e implementar operações reversíveis.

### Iterator

Fornece um meio de acessar sequencialmente os elementos de um agregado sem expor sua representação subjacente.

### Mediator

Define um objeto que encapsula a forma como um conjunto de objetos interage, promovendo um baixo acoplamento ao evitar que os objetos se refiram uns aos outros explicitamente.

### Memento

Sem violar o encapsulamento, captura e externaliza o estado interno de um objeto, de modo que o objeto possa ser restaurado para este estado mais tarde.

### Observer

Define uma dependência um-para-muitos entre objetos, onde quando um objeto muda de estado, todos os seus dependentes são notificados e atualizados automaticamente.

### State

Permite que um objeto altere seu comportamento quando seu estado interno muda, parecendo ter mudado de classe.

### Strategy

Define uma família de algoritmos, encapsula cada um deles e os torna intercambiáveis. O Strategy permite que o algoritmo varie independentemente dos clientes que o utilizam.

### Template Method

Define o esqueleto de um algoritmo em uma operação, adiando alguns passos para subclasses. O Template Method permite que subclasses redefinam certos passos de um algoritmo sem mudar sua estrutura.

### Visitor

Representa uma operação a ser realizada sobre os elementos da estrutura de um objeto. O Visitor permite definir uma nova operação sem mudar as classes dos elementos sobre os quais opera.

## Padrão Strategy

De acordo com o guia Refactoring Guru<sup>1</sup>, o padrão de design Strategy tem como objetivo definir uma família de algoritmos, encapsulá-los e torná-los intercambiáveis. O Strategy permite que o algoritmo varie independentemente dos clientes que o utilizam. Isso é particularmente útil para situações onde há múltiplas formas de executar uma operação e a escolha do algoritmo deve ser feita em tempo de execução.

### Vantagens do Padrão Strategy

- **Desacoplamento:** Promove baixo acoplamento entre a classe que usa o algoritmo e as diferentes implementações do algoritmo.
- **Flexibilidade:** Permite que novos algoritmos sejam adicionados a qualquer momento sem modificar as classes que utilizam esses algoritmos.
- **Manutenção:** Facilita a manutenção e a extensão do código, pois novos comportamentos podem ser introduzidos sem alterar o código existente.

### Desvantagens do Padrão Strategy

- **Complexidade Adicional:** Pode introduzir complexidade adicional ao código devido ao aumento no número de classes.
- **Escolha do Algoritmo:** A escolha do algoritmo apropriado pode ser delegada ao cliente, o que pode aumentar a complexidade de uso da classe.

[REFATORAÇÃO GURU](https://refactoring.guru/pt-br/design-patterns). Acesso em 23 de Julho de 2024.


## Diagrama de Padrão Strategy

Este diagrama de classes UML ilustra a implementação do padrão de projeto Strategy para gerenciar permissões de usuários em um sistema:

<br>
<figure align="center">
  <img src="https://raw.githubusercontent.com/UnBArqDsw2024-1/2024.1_G5_My_AudioPodCast/main/docs/PadroesDeProjeto/assets/diagrama_strategy.png" alt="Diagrama do Strategy">
  <figcaption>Figura 1 - Diagrama de Classes para o Padrão Strategy<br>Fonte: ArqDsw Grupo 05 - 2024.1(UnB FGA)</figcaption>
</figure>
<br><br>

### Descrição do Diagrama

#### Classe `User`

- **Atributos:**
  - `idUser: int`: Identificador único do usuário.
  - `name: str`: Nome do usuário.
  - `age: int`: Idade do usuário.
  - `email: str`: E-mail do usuário.
  - `password: str`: Senha do usuário.
  - `permission_strategy: UserPermissionStrategy`: Referência para a estratégia de permissão utilizada pelo usuário.
- **Métodos:**
  - `set_permission_strategy(strategy: UserPermissionStrategy): void`: Define a estratégia de permissão para o usuário.
  - `access_resources(): str`: Método para acessar recursos com base na estratégia de permissão.
- **Implementação:**

  ```
    class User:
        def __init__(self):
            self.name = ""
            self.age = 0
            self.email = ""
            self.password = ""
            self.permission_strategy = None

        def set_permission_strategy(self, strategy: UserPermissionStrategy):
            self.permission_strategy = strategy

        def access_resources(self):
            if self.permission_strategy:
                return self.permission_strategy.access_resources()
            return "Permissão não definida."
  ```

#### Interface `UserPermissionStrategy`

- Método `access_resources(): str`: Define a assinatura do método para acessar recursos.
- Implementação:
  ```
  class UserPermissionStrategy(ABC):
    @abstractmethod
    def access_resources(self):
        pass
  ```

#### Classes Concretas de Estratégias de Permissão

- **`AdminUserPermissionStrategy`**
  - Implementa a interface `UserPermissionStrategy`.
  - Método `access_resources(): str` define a lógica específica para usuários administradores.
  - Implementação:
    ```
    class AdminUserPermissionStrategy(UserPermissionStrategy):
      def access_resources(self):
          return "Acesso completo a todos os recursos."
    ```
- **`DefaultUserPermissionStrategy`**
  - Implementa a interface `UserPermissionStrategy`.
  - Método `access_resources(): str` define a lógica específica para usuários padrão.
  - Implementação:
    ```
    class DefaultUserPermissionStrategy (UserPermissionStrategy):
      def access_resources(self):
          return "Acesso limitado a recursos padrão."
    ```
- **`HostUserPermissionStrategy`**
  - Implementa a interface `UserPermissionStrategy`.
  - Método `access_resources(): str` define a lógica específica para usuários anfitriões.
  - Implementação:
    ```
    class HostUserPermissionStrategy(UserPermissionStrategy):
      def access_resources(self):
          return "Acesso a recursos específicos do host."
    ```

### Explicação

A classe `User` possui um atributo `permission_strategy` que referencia uma instância de `UserPermissionStrategy`. Isso permite que a estratégia de permissão seja alterada em tempo de execução, proporcionando flexibilidade.

A interface `UserPermissionStrategy` define um contrato para todas as estratégias de permissão.

As classes concretas (`AdminUserPermissionStrategy`, `DefaultUserPermissionStrategy` e `HostUserPermissionStrategy`) implementam a interface e definem o comportamento específico para cada tipo de usuário.

Este diagrama exemplifica o uso do padrão Strategy, permitindo que diferentes comportamentos de acesso a recursos sejam intercambiáveis em tempo de execução para a classe `User`.

## Referências Biliográficas

>[1] REFACTORING GURU. Strategy. Behavioral Design Patterns. Disponível em: https://refactoring.guru/pt-br/design-patterns/behavioral-patterns. Acesso em: 24 jul. 2024.


## Bibliografia

- GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. Design Patterns: Elements of Reusable Object-Oriented Software. 1. ed. Boston: Addison-Wesley, 1994.
- LARMAN, Craig. Utilizando UML e Padrões: Uma Introdução a Análise e ao Projeto Orientado a Objetos. 3a. edição. Bookman, 2007.
- COCKBURN, Alistair. Escrevendo Casos de Uso Eficazes. Bookman, 2005.
- SILVA, Ricardo Pereira. UML 2 em Modelagem Orientada a Objetos. Visual Books, 2007.
- PRESSMAN, Roger S. Engenharia de Software. 6a. edição. McGraw-Hill, 2006.
- IEEE. SWEBOK-Guide to the Software Engineering Body of Knowledge, 2004.
- SOMMERVILLE, Ian. Engenharia de Software. 8a. edição. Pearson, 2007.

## Histórico de Versão

| Data       | Versão | Modificação                                                    | Autor                    | Revisor            |
| ---------- | ------ | -------------------------------------------------------------- | ------------------------ | ------------------ |
| 24/07/2024 | 0.1    | Criação do Artefato                                            | Arthur D'Assumpção       | Emerson Teles      |
| 24/07/2024 | 0.2    | Descrição do Diagrama e Implementação                          | Emerson Teles            | Arthur D'Assumpção |
| 24/07/2024 | 0.3    | Adiciona modelagem e codificação inicial do Strategy           | Caio Braga               | Caio Lelis         |
| 24/07/2024 | 0.4    | Adiciona codificação final do Strategy e revisão bibliográfica | Caio Lelis               | Caio Braga         |
| 25/07/2024 | 0.5    | Revisa conteúdo e adiciona referência na Introdução            | Caio Lucas e Caio Felipe |                    |
| 25/07/2024 | 0.6    | Revisão do conteúdo                                            | Delziron Braz            |                    |


